1. Without DI: DamselRescuingKnight

/*
* As you can see, DamselRescuingKnight creates its own quest, a RescueDamselQuest,
in the constructor. This makes a DamselRescuingKnight tightly coupled to a Rescue-
DamselQuest and severely limits the knight’s quest-embarking repertoire. If a damsel
needs rescuing, this knight’s there. But if a dragon needs slaying or a round table
needs … well … rounding, then this knight’s going to have to sit it out.

What’s more, it’d be terribly difficult to write a unit test for DamselRescuingKnight.

In such a test, you’d like to be able to assert that the quest’s embark() method is called when the knight’s embarkOnQuest() method is called.

But there’s no clear way to accomplish that here. Unfortunately, DamselRescuingKnight will remain
untested.
* */
2. With DI: BraveKnight

BraveKnight doesn’t create his own quest. Instead, he’s given a quest at construction time as a constructor argument.

This is a type of DI known as constructor injection (others like setter, interface injection).
What’s more, the quest he’s given is typed as Quest, an interface that all quests implement.
So BraveKnight could embark on a RescueDamselQuest, a SlayDragonQuest, a
MakeRoundTableRounderQuest, or any other Quest implementation he’s given.
The point is that BraveKnight isn’t coupled to any specific implementation of
Quest. It doesn’t matter to him what kind of quest he’s asked to embark on, as long as
it implements the Quest interface. That’s the key benefit of DI—loose coupling. If an
object only knows about its dependencies by their interface (not by their implementation
or how they’re instantiated), then the dependency can be swapped out with a different
implementation without the depending object knowing the difference.
One of the most common ways a dependency is swapped out is with a mock implementation
during testing. You were unable to adequately test DamselRescuingKnight
due to tight coupling, but you can easily test BraveKnight by giving it a mock implementation
of Quest, as shown next.


3
Only Spring, through its configuration, knows how all the pieces
come together. This makes it possible to change those dependencies with no changes
to the depending classes.


4 KnightMain class


II. AOP

1. Aspect-Oriented-Programming (AOP) enables you to capture functionality that’s used
   throughout your application in reusable components

   System services such as logging, transaction management, and security each responsible for a specific
   piece of functionality. But often these components also carry additional responsibilities
   beyond their core functionality.


   These system services are commonly referred to as cross-cutting
   concerns because they tend to cut across multiple components in a system.

   Cause two problem:
   1) The code that implements the system-wide concerns is duplicated across multiple
      components. It becomes very complicate to modify.
   2) Your components are littered with code that isn’t aligned with their core functionality.


   Solution:
   1) AOP makes it possible to modularize these services and then apply them declaratively
             to the components they should affect.
   2) In short, aspects ensure that POJOs remain plain.
   3) With AOP, application-wide concerns (such as transactions and security) are decoupled
      from the objects to which they’re applied.